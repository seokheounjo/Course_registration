# 수강신청 시스템 개발부터 배포까지 - 예상 질문과 답변 정리

## 📚 프로젝트 전체 과정 관련 질문

### Q1. "개발부터 배포까지"라는 제목의 의미는?
**A:** 이 프로젝트는 소프트웨어 개발 생명주기(SDLC) 전체를 다룹니다. 요구사항 분석부터 설계, 개발, 테스트, 배포, 운영까지 - 실제 현업에서 이루어지는 전체 과정을 경험했습니다. 특히 **"코드 한 줄 수정부터 프로덕션 반영까지 4분"**이라는 완전 자동화 파이프라인을 구축하여 진정한 End-to-End 개발을 실현했습니다.

### Q2. 혼자서 이 모든 과정을 다 할 수 있었나요?
**A:** 체계적인 Phase별 접근으로 가능했습니다. **6단계 개발 과정**으로 나누어 진행했습니다: Phase 1-2(분석/설계), Phase 3-4(백엔드/프론트엔드), Phase 5-6(DevOps/인프라). 각 단계마다 명확한 목표를 설정하고 문서화를 철저히 했습니다. 무엇보다 **실제 24시간 운영되는 서비스**로 모든 것을 검증하며 진행했습니다.

### Q3. 실제 현업과 비교했을 때 어떤 차이가 있을까요?
**A:** 현업에서는 팀 단위 역할 분담과 더 복잡한 비즈니스 요구사항이 있을 것입니다. 하지만 이 프로젝트에서는 **전체 기술 스택을 직접 구현**하면서 각 영역의 연결점을 이해할 수 있었습니다. 특히 **DevOps 자동화, 클라우드 인프라, 모니터링**까지 경험해서 팀에서 다른 역할과의 소통이 더 효과적일 것 같습니다.

## 📋 프로젝트 설계 및 아키텍처 질문

### Q4. 이중 배포 전략을 채택한 이유는?
**A:** **개발 속도와 운영 안정성을 모두 확보**하기 위해서입니다. **EC2 직접 배포**는 SSH를 통한 즉시 배포로 빠른 프로토타이핑이 가능하고, **EKS GitOps 배포**는 ArgoCD 자동화로 운영 환경의 안정성을 제공합니다. 두 환경이 **동일한 AWS RDS를 공유**하여 데이터 일관성을 보장하면서도 각각의 장점을 활용할 수 있습니다.

### Q5. 시스템 아키텍처 설계 시 가장 중요하게 고려한 점은?
**A:** **확장성과 자동화**를 최우선으로 고려했습니다. 3계층 아키텍처로 관심사를 분리하고, 컨테이너 기반으로 설계하여 스케일링이 용이하도록 했습니다. 특히 **CI/CD 완전 자동화**로 개발자가 코드에만 집중할 수 있는 환경을 구축했고, **Kubernetes + ArgoCD**로 선언적 배포를 구현했습니다.

### Q6. 25개 API 엔드포인트의 설계 원칙은?
**A:** **RESTful API 설계 원칙**을 따랐습니다. 학생(Student), 교수(Professor), 과목(Subject), 수강신청(Enrollment) 리소스별로 CRUD 엔드포인트를 체계적으로 구성했습니다. **HTTP 메소드(GET, POST, PUT, DELETE)**와 **HTTP 상태 코드**를 의미에 맞게 사용하고, **권한별 접근 제어**를 적용했습니다. 또한 **실시간 대시보드용 통계 API**도 별도 구현했습니다.

## 🍃 Spring Boot 백엔드 관련 질문

### Q7. Spring Boot 3.1.2를 선택한 이유는?
**A:** **최신 LTS 버전의 안정성과 성능 향상** 때문입니다. Java 17과의 완벽한 호환성, 향상된 Native Image 지원, 그리고 **Auto Configuration**으로 복잡한 설정 없이 빠른 개발이 가능했습니다. 또한 **내장 Tomcat**으로 독립 실행 가능한 JAR를 만들어 Docker 컨테이너화에 최적화되었습니다.

### Q8. 복잡한 JPQL 쿼리를 직접 작성한 이유는?
**A:** **시간 충돌 검사**라는 복잡한 비즈니스 로직 때문입니다. 단순 JPA 메소드로는 "두 시간대가 겹치는 모든 케이스"를 검사하기 어려웠습니다. **시작시간≤기준시작시간<종료시간** 등의 복잡한 조건을 JPQL로 직접 작성하여 정확한 시간 충돌 검증을 구현했습니다. 이는 실무에서도 자주 필요한 복잡 쿼리 작성 능력을 보여줍니다.

### Q9. @Transactional 적용 전략은?
**A:** **Service Layer**에 적용하여 비즈니스 단위의 트랜잭션을 보장했습니다. 특히 **수강신청 프로세스**는 4단계 검증(학생 확인→중복 검사→시간 충돌→정원 확인→등록)이 하나의 트랜잭션으로 처리되어야 합니다. 중간에 오류 발생 시 전체 롤백되어 **데이터 일관성**을 보장합니다.

## 🎨 Frontend & Database 관련 질문

### Q10. Mustache를 선택한 이유는?
**A:** **서버사이드 렌더링과 SEO 최적화** 때문입니다. React나 Vue.js 같은 SPA 대신 Mustache를 선택한 이유는: ①Spring Boot와의 완벽한 통합 ②서버에서 데이터를 직접 렌더링하여 초기 로딩 속도 향상 ③SEO 친화적 ④로직과 뷰의 완전 분리로 간결한 템플릿. 추가로 **JavaScript ES6+**로 실시간 검증을 구현하여 UX도 향상시켰습니다.

### Q11. JavaScript 실시간 검증의 핵심 구현은?
**A:** **클라이언트 사이드에서 즉시 피드백**을 제공합니다. 학점 계산(`calculateTotalCredits`), 시간 충돌 검사(`hasTimeConflict`) 함수로 사용자가 과목을 선택하는 순간 바로 검증 결과를 보여줍니다. **서버 요청 없이 즉시 반응**하여 UX가 크게 향상되고, 서버 부하도 감소시킵니다.

### Q12. 환경별 데이터베이스 구성 전략은?
**A:** **Profile 기반 자동 전환**을 구현했습니다. **개발환경**은 H2 인메모리 DB로 빠른 테스트와 개발이 가능하고, **프로덕션**은 AWS RDS MySQL로 안정적인 운영을 제공합니다. `application.properties`와 `application-prod.properties`로 분리하여 `SPRING_PROFILES_ACTIVE` 환경변수 하나로 자동 전환됩니다.

## 🐳 Docker & 컨테이너화 관련 질문

### Q13. Multi-stage 빌드로 60% 이미지 최적화를 달성한 방법은?
**A:** **빌드와 런타임을 완전히 분리**했습니다. **Builder stage**에서는 JDK + Gradle로 애플리케이션을 빌드하고, **Production stage**에서는 JRE만으로 실행합니다. 최종 이미지에서 **빌드 도구, 소스코드, 캐시**가 모두 제거되어 이미지 크기가 대폭 줄어들고 보안도 향상됩니다.

### Q14. Docker Compose의 Health Check 구현 목적은?
**A:** **서비스 간 의존성 문제 해결**입니다. MySQL이 완전히 준비되기 전에 애플리케이션이 시작되면 DB 연결 오류가 발생합니다. `healthcheck`와 `condition: service_healthy`로 MySQL 준비 완료 후에만 애플리케이션이 시작되도록 하여 **시작 순서를 제어**합니다.

### Q15. 컨테이너화의 가장 큰 이점은?
**A:** **"Dev=Prod" 환경 일관성**입니다. 로컬 개발부터 프로덕션까지 동일한 컨테이너로 실행되므로 "내 컴퓨터에서는 잘 되는데" 문제가 완전히 해결됩니다. 또한 **Docker Hub Registry**를 통한 중앙 관리와 **버전 태깅 전략**으로 롤백도 즉시 가능합니다.

## ⚡ CI/CD 자동화 관련 질문

### Q16. 4분 완전 자동화를 달성한 핵심은?
**A:** **GitHub Actions + ArgoCD 조합**입니다. **CI 파이프라인**에서 테스트→빌드→Docker 이미지 푸시→EC2 배포를 **평균 3분**에 처리하고, **GitOps CD**에서 ArgoCD가 변경사항을 감지하여 EKS에 **평균 1분**에 배포합니다. **캐싱과 병렬 처리**로 시간을 최적화했습니다.

### Q17. GitOps의 핵심 장점은?
**A:** **Git을 Single Source of Truth**로 사용하는 것입니다. 기존 Push 방식과 달리 **Pull 방식**으로 ArgoCD가 Git을 모니터링하며 자동 동기화합니다. ①배포 상태를 Git으로 추적 가능 ②롤백은 Git revert로 간단히 처리 ③**Self-Heal 기능**으로 설정 드리프트 자동 복구 ④**Prune Policy**로 삭제된 리소스 자동 정리.

### Q18. CI/CD 파이프라인 99.5% 성공률의 비결은?
**A:** **철저한 테스트와 단계적 검증**입니다. ①빌드 단계에서 컴파일 오류 사전 차단 ②단위 테스트로 로직 검증 ③Docker 이미지 빌드 검증 ④배포 전 헬스체크 확인. 실패 시 **즉시 알림**과 **자동 롤백**으로 신속한 복구가 가능합니다.

## ☸️ Kubernetes & AWS 관련 질문

### Q19. EKS에서 고가용성을 어떻게 구현했나요?
**A:** 여러 계층에서 고가용성을 확보했습니다. ①**2개 Replica**로 Pod 이중화 ②**Liveness/Readiness Probe**로 헬스체크 ③**LoadBalancer Service**로 트래픽 분산 ④**Resource Limits**로 안정적 리소스 관리 ⑤**Auto Restart**로 Pod 장애 시 자동 복구. 실제로 **99.9% 업타임**을 달성하고 있습니다.

### Q20. VPC 피어링으로 Cross-VPC 통신을 구현한 이유는?
**A:** **EKS와 RDS가 서로 다른 VPC**에 생성되어 네트워크 통신이 불가능했기 때문입니다. VPC 피어링으로 **private 네트워크 연결**을 구현하여 ①인터넷을 거치지 않는 안전한 통신 ②**라우팅 테이블 업데이트**로 트래픽 경로 설정 ③**보안 그룹 최소 권한**으로 필요한 포트만 개방했습니다.

### Q21. AWS 멀티 서비스 통합의 복잡성은?
**A:** **네트워킹, 보안, 모니터링**을 종합적으로 고려해야 했습니다. EC2, EKS, RDS, VPC를 통합하면서 ①**IAM 역할과 정책** 설정 ②**Security Group** 규칙 관리 ③**VPC 피어링** 네트워크 설계 ④**RDS 엔드포인트** 연결 등을 모두 직접 구현했습니다. 이는 실무에서 매우 중요한 클라우드 아키텍처 설계 경험입니다.

## 🚨 문제 해결 및 트러블슈팅 관련 질문

### Q22. VPC 네트워킹 문제를 어떻게 해결했나요?
**A:** **체계적인 네트워크 디버깅**으로 해결했습니다. ①문제 파악: EKS↔RDS 통신 불가 ②원인 분석: 서로 다른 VPC (vpc-0106946af7a80228d vs vpc-0a532f02a6fa732c6) ③해결 방법: VPC 피어링 연결 생성 ④검증: 라우팅 테이블 업데이트와 보안 그룹 규칙 추가. 이 과정에서 **AWS 네트워킹 심화 지식**을 습득했습니다.

### Q23. Docker 이미지 불일치 문제의 해결 과정은?
**A:** **체계적인 디버깅 접근**을 했습니다. ①증상: GitHub Actions 배포 실패 ②로그 분석: 잘못된 DockerHub 리포지토리 참조 ③원인: 사용자명 불일치 (seokheounjo → procof) ④해결: GitHub Secrets 재설정과 YAML 파일 수정. **로그 분석 능력과 시크릿 관리**의 중요성을 배웠습니다.

### Q24. 데이터베이스 초기화 충돌을 어떻게 해결했나요?
**A:** **환경별 설정 분리**로 해결했습니다. ①문제: data.sql 중복 키 에러로 애플리케이션 시작 실패 ②분석: 개발과 프로덕션 환경의 데이터 초기화 정책 차이 ③해결: `SPRING_SQL_INIT_MODE=never` 환경변수로 프로덕션에서 SQL 초기화 비활성화 ④결과: 환경별 독립적 운영 가능.

## 🔐 보안 및 운영 관련 질문

### Q25. 애플리케이션 보안은 어떻게 구현했나요?
**A:** **다중 계층 보안**을 적용했습니다. ①**SQL Injection 방지**: JPA Prepared Statement 사용 ②**XSS 방지**: 입력값 검증과 출력 이스케이핑 ③**세션 관리**: HttpSession 기반 인증 ④**권한별 접근 제어**: 학생/교수/관리자 역할 분리 ⑤**HTTPS 적용**: 모든 통신 암호화 계획.

### Q26. AWS 인프라 보안 모범 사례는?
**A:** **최소 권한 원칙**을 철저히 적용했습니다. ①**IAM 역할**: 서비스별 최소 필요 권한만 부여 ②**VPC 분리**: EKS와 RDS를 private subnet에 배치 ③**Security Group**: 필요한 포트만 개방 (8087, 3306, 22) ④**VPC 피어링**: 안전한 private 네트워크 통신 ⑤**RDS 접근 제한**: 직접 접근 차단, 애플리케이션을 통해서만 접근.

### Q27. 실시간 모니터링은 어떻게 구현했나요?
**A:** **4-카드 대시보드**로 핵심 지표를 실시간 추적합니다. ①**학생 수**: COUNT 쿼리로 등록된 학생 현황 ②**교수 수**: 중복 제거 후 실제 교수 현황 ③**과목 수**: 개설 과목 현황 ④**수강신청 수**: 실제 수강신청 현황. 관리자가 접속할 때마다 **AWS RDS에서 실시간 조회**하여 최신 상태를 반영합니다.

## 📈 성능 및 확장성 관련 질문

### Q28. 대용량 트래픽을 처리하려면 어떻게 개선하겠나요?
**A:** **단계적 확장 전략**을 수립했습니다. ①**캐싱**: Redis로 자주 조회되는 데이터 메모리 저장 ②**CDN**: 정적 리소스 분산 배치 ③**데이터베이스**: Read Replica로 읽기 부하 분산 ④**스케일링**: Kubernetes HPA로 자동 스케일링 ⑤**성능 테스트**: JMeter로 병목지점 식별 및 최적화. **수만 명 동시 사용자**를 목표로 하고 있습니다.

### Q29. 마이크로서비스로 전환한다면?
**A:** **도메인별 서비스 분리**를 계획하고 있습니다. ①**User Service**: 학생/교수 관리 ②**Course Service**: 과목 관리 ③**Enrollment Service**: 수강신청 관리 ④**Notification Service**: 알림 처리. 각 서비스는 독립적인 데이터베이스를 갖고, **API Gateway**로 라우팅, **Kafka**로 비동기 통신, **Istio**로 Service Mesh를 구현할 예정입니다.

### Q30. 현재 시스템의 성능 지표는?
**A:** **실제 운영 환경**에서 검증된 지표입니다. ①**응답 시간**: 평균 200ms 이하 ②**처리량**: 동시 접속자 50명 이상 처리 가능 ③**가용성**: 99.9% 업타임 달성 ④**배포 시간**: 4분 내 완전 자동화 ⑤**성공률**: CI/CD 파이프라인 99.5% 성공. 실제 **24시간 운영**으로 모든 지표를 검증하고 있습니다.

## 💡 학습 및 성장 관련 질문

### Q31. 이 프로젝트를 통해 얻은 가장 큰 배움은?
**A:** **"개발자에서 소프트웨어 엔지니어로의 성장"**입니다. 단순히 코딩만 하는 것이 아니라 ①시스템 설계와 아키텍처 ②인프라 구성과 자동화 ③모니터링과 운영 ④문제 해결과 최적화까지 - **전체 소프트웨어 생명주기**를 경험했습니다. 특히 **실제 운영 서비스**를 통해 이론이 아닌 실무 역량을 쌓았습니다.

### Q32. 다음에 도전하고 싶은 기술 스택은?
**A:** **3가지 영역**에 관심이 있습니다. ①**마이크로서비스**: Service Mesh (Istio), 분산 추적 (Jaeger) ②**이벤트 드리븐**: Apache Kafka, Event Sourcing ③**클라우드 네이티브**: Serverless (AWS Lambda), Multi-Region 배포. 특히 현재 시스템을 **마이크로서비스로 전환**하면서 분산 시스템의 복잡성을 다뤄보고 싶습니다.

### Q33. 팀 프로젝트라면 어떤 부분을 개선하겠나요?
**A:** **협업 프로세스 체계화**가 우선입니다. ①**Git Strategy**: GitHub Flow로 브랜치 전략 정립 ②**Code Quality**: 코드 리뷰, 페어 프로그래밍 도입 ③**프로젝트 관리**: Jira/Notion으로 이슈 관리 ④**커뮤니케이션**: 데일리 스탠드업, 회고를 통한 지속적 개선 ⑤**문서화**: API 문서, 아키텍처 문서 체계화.

## 🎯 마무리 & 차별화 포인트 질문

### Q34. 다른 프로젝트와 차별화되는 가장 큰 특징은?
**A:** **"실제 24시간 운영 중인 서비스"**라는 점입니다. ①단순한 로컬 데모가 아닌 **AWS 클라우드 실서비스** ②언제든 http://23.22.154.180 에서 체험 가능 ③**실시간 데이터베이스 통계** 확인 가능 ④**4분 자동화 배포**가 실제로 작동 중 ⑤모든 기능이 **현재도 운영** 중. 이론이 아닌 **실무 검증**된 시스템입니다.

### Q35. 이 프로젝트의 가장 자랑스러운 부분은?
**A:** **완전 자동화 DevOps 파이프라인**입니다. GitHub에 코드를 푸시하면 ①테스트 자동 실행 ②Docker 이미지 자동 빌드 ③DockerHub 자동 푸시 ④EC2 자동 배포 ⑤EKS GitOps 자동 동기화 - **모든 과정이 4분 내에 완전 자동**으로 처리됩니다. **기존 수동 배포 대비 10배 이상의 효율성 향상**을 달성했습니다.

### Q36. 향후 이 프로젝트를 어떻게 발전시킬 계획인가요?
**A:** **3단계 발전 계획**을 수립했습니다. 
**단기(3개월)**: Prometheus+Grafana 모니터링, ELK Stack 로그 관리, SSL/TLS 보안 강화
**중기(6-12개월)**: 마이크로서비스 전환, API Gateway, Kafka 이벤트 드리븐
**장기(1년+)**: 엔터프라이즈급 플랫폼으로 확장, Multi-Region 배포, 수만 명 동시 사용자 지원
현재의 **견고한 기반** 위에 더 큰 규모의 시스템으로 발전시킬 것입니다.

---

## 🎪 실시간 데모 대응

### 발표 중 실제 사이트 시연 시 핵심 포인트:

1. **실시간 접속 테스트**: 발표 30분 전 반드시 확인
2. **관리자 데모 순서**: 
   - http://23.22.154.180 접속
   - admin/admin 로그인
   - "데이터베이스 현황" 클릭
   - **"지금 이 순간의 실시간 AWS RDS 데이터입니다!"** 강조
3. **학생 계정 데모**: 20231000/20231000으로 수강신청 기능 시연
4. **백업 계획**: 사이트 접속 불가 시 스크린샷 활용

### 기술적 질문 대응 전략:

1. **모르는 질문**: "좋은 질문입니다! 현재는 [구현 부분]까지 완성했고, [해당 기술]은 향후 학습 계획에 포함되어 있습니다."
2. **깊은 기술 질문**: 핵심 원리만 설명하고 "실제 구현 경험을 바탕으로 더 깊이 학습할 예정"으로 마무리
3. **비교 질문**: 선택 기술의 장점 먼저 설명 후 다른 기술의 장점도 인정하며 균형감 유지

**핵심은 "실제 운영 서비스"라는 차별화 포인트를 지속적으로 강조하는 것입니다!**